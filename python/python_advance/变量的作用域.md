## 变量的作用域
**对于不可变变量b，在函数f1()中先赋值后引用,此时的变量b只是函数中定义的局部变量，与全局变量b没有任何关系。**

```python
b = 6  
def f1():  
    # b只是f1()中的局部变量，与全局变量的b没有任何关系
    b = 1  
    print(b)  # 1  
if __name__ == '__main__':  
    f1()  
    print(b)  # 6
```

**在函数f1()中并没有声明变量b,直接引用的话，会在上层作用域搜索到全局变量b.**

```python
b = 6  
def f1():  
    # 直接引用变量b,在局部变量中并没有找到b的声明，就会去上一层找到全局变量b  
    print(b)  # 6  
if __name__ == '__main__':  
    f1()  
    print(b)  # 6
```

**在函数f1()中，先引用变量b，然后在对变量b进行赋值操作，会编译报错。因为此时python认为变量b是f1()作用域内的局部变量，但是在f1()函数内并没有对变量b的声明。**

```python
b = 6  
def f1():  
    # 先引用，后赋值，编译不通过  
    # 此时认为b是f1()的局部变量，但是在引用的时候并没有在函数内找到该局部变量  
    print(b)  # 报错
    b = 2  
if __name__ == '__main__':  
    f1()  
    print(b)
```

**通过global关键字声明变量b是全局的变量b，可以解决上面的问题。**

```python
b = 6  
def f1():  
    # 可以通过global关键字来声明这是全局变量b  
    global b  
    print(b)  # 6  
    b = 2  
if __name__ == '__main__':  
    f1()  
    print(b)  # 2
```

**嵌套函数中，内函数引用并修改外函数中的局部变量，需要nonlocal关键字来声明，这是一个自由变量。**

```python
def f3():  
    c = 2  
    def f4():  
        nonlocal c  
        # 嵌套函数，内函数引用并修改外函数的不可变变量，要通过nonlocal关键字声明这是自由变量  
        c += 2  
        print(c)  
    return f4  
if __name__ == '__main__':  
    f4 = f3()  
    f4()  # 4
```

**由上可见，函数中引用并修改作用域之外的不可变变量，如果是全局变量，可以通过global关键字先声明后使用，如果是非全局变量，可以通过nonlocal关键字声明使用。**
## 闭包
闭包：**引入了自由变量的函数就是闭包**。被引入的自由变量和函数一同存在，即使这个变量已经离开了创造它的环境也不例外。（或者理解：**嵌套函数中，内函数引用了外函数中的局部变量，并且外函数的返回值是内函数的引用，这样就形成了一个闭包**。）

**一般对函数的理解**：函数再被调用的时候，会在栈上创建其执行环境，初始化其中定义的变量和外部参数，以便函数执行下一步的操作。当函数执行完成后，返回函数结果，函数之前的栈内存便会被销毁，函数中的临时变量以及计算的中间结果都不会保存。每次调用执行函数，都会重新初始化函数的执行环境。

**闭包是另一种情况**：外部函数发现自己的临时变量会在将来的内部函数中使用到，外部函数在结束自己返回内函数引用的同时，会把外部函数的临时变量和内函数绑定在一起，所以，即使外部函数已经结束了，但是调用内部函数的时候，仍可以使用外部函数的临时变量，也就是自由变量。

```python
def outer(a, b):  
    def inner(x):  
        return a*x + b  
    return inner  
if __name__ == '__main__':  
    inn = outer(2, 2)  
    print(inn(1))  # 4  
    print(inn(2))  # 6  
    # 查看内函数的自由变量 ('a', 'b')  
    print(inn.__code__.co_freevars)  
```
