以下是一个简单的 Java 多线程并行处理的示例代码：

```java
import java.util.ArrayList;
import java.util.List;

public class ParallelProcessingDemo {

    public static void main(String[] args) {
        // 创建一个任务列表
        List<Runnable> tasks = new ArrayList<>();
        tasks.add(new Task("Task 1"));
        tasks.add(new Task("Task 2"));
        tasks.add(new Task("Task 3"));
        tasks.add(new Task("Task 4"));

        // 创建线程列表
        List<Thread> threads = new ArrayList<>();

        // 启动线程并开始执行任务
        for (Runnable task : tasks) {
            Thread thread = new Thread(task);
            thread.start();
            threads.add(thread);
        }

        // 等待所有线程执行完毕
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println("All tasks completed.");
    }

    static class Task implements Runnable {
        private final String name;

        public Task(String name) {
            this.name = name;
        }

        @Override
        public void run() {
            System.out.println("Executing " + name + " in thread " + Thread.currentThread().getName());
            // 执行任务逻辑
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("Completed " + name + " in thread " + Thread.currentThread().getName());
        }
    }
}
```

在上述示例中，我们创建了一个 `ParallelProcessingDemo` 类，其中包含一个 `Task` 内部类实现了 `Runnable` 接口。`Task` 类代表要并行处理的任务。

在 `main` 方法中，我们创建了一个任务列表 `tasks`，其中包含了四个任务。然后，我们创建了一个线程列表 `threads`，用于存储线程对象。

接下来，我们使用 `for` 循环遍历任务列表，并为每个任务创建一个线程对象。我们启动线程并将其加入到线程列表中。

最后，我们使用另一个 `for` 循环等待所有线程执行完毕，通过调用 `join` 方法实现。最后打印出所有任务完成的消息。

运行该示例代码，你将看到任务以并行方式在多个线程中执行。

请注意，在实际应用中，你可能需要根据具体需求进行更复杂的线程管理和任务处理。上述示例提供了一个基本的框架，你可以根据自己的业务逻辑和需求进行进一步的定制和扩展。

# 让代码更优雅
当涉及到多线程并行处理时，可以使用 Java 8 引入的 `ExecutorService` 和 `CompletableFuture` 来使代码更优雅。下面是一个使用 `ExecutorService` 和 `CompletableFuture` 的优雅多线程并行处理的示例代码：

```java
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ParallelProcessingDemo {

    public static void main(String[] args) throws Exception {
        // 创建一个任务列表
        List<Runnable> tasks = new ArrayList<>();
        tasks.add(() -> performTask("Task 1"));
        tasks.add(() -> performTask("Task 2"));
        tasks.add(() -> performTask("Task 3"));
        tasks.add(() -> performTask("Task 4"));

        // 创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(tasks.size());

        // 使用 CompletableFuture 来提交任务并获取结果
        List<CompletableFuture<Void>> futures = new ArrayList<>();
        for (Runnable task : tasks) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(task, executorService);
            futures.add(future);
        }

        // 等待所有任务完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();

        // 关闭线程池
        executorService.shutdown();
        executorService.awaitTermination(1, TimeUnit.MINUTES);

        System.out.println("All tasks completed.");
    }

    private static void performTask(String taskName) {
        System.out.println("Executing " + taskName + " in thread " + Thread.currentThread().getName());
        // 执行任务逻辑
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Completed " + taskName + " in thread " + Thread.currentThread().getName());
    }
}
```

在上述代码中，我们使用了 `ExecutorService` 来创建一个线程池，并使用 `CompletableFuture` 来提交任务和获取结果。

首先，我们创建了一个任务列表 `tasks`，其中包含了四个任务。然后，我们创建了一个固定大小的线程池 `executorService`，大小与任务列表中的任务数量相同。

接下来，我们使用 `CompletableFuture` 的 `runAsync` 方法将每个任务提交给线程池执行，并将返回的 `CompletableFuture` 添加到 `futures` 列表中。

使用 `CompletableFuture.allOf` 方法，我们等待所有任务的完成。这里，我们将 `futures` 列表转换为 `CompletableFuture` 数组，并传递给 `allOf` 方法。通过调用 `get` 方法，我们可以阻塞等待所有任务的完成。

最后，我们关闭线程池并等待所有线程的终止，然后打印出所有任务完成的消息。

这种方式利用了 Java 8 提供的函数式编程特性，可以更清晰、简洁地实现多线程并行处理，同时还能获得任务的执行结果。

请注意，在实际应用中，你可以根据需要调整线程池的大小和其他配置，以及使用 `CompletableFuture` 的其他方法来处理异常、处理任务结果等。

使用 `ExecutorService` 和 `CompletableFuture` 可以更好

地控制和管理多线程并行处理，同时提供了更强大的功能和灵活性。
