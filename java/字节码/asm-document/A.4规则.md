# A.4 规则

现在回忆一下为确保你的代码能与较早的 ASM 版本保持后向兼容性而必须遵循的规则（见第 5 章和第 10 章）。

- 规则 1：要为 ASM X 编写一个 ClassVisitor 子类，就以这个版本号为参数，调用ClassVisitor 构造器，在这个版本的 ClassVisitor 类中，绝对不要重写或调用被弃用的方法（或者将在之后版本引入的方法）。
- 规则 2：不要使用访问器的继承，而要使用委托（即访问器链）。一种好的做法是让你的访问器类在默认情况下成为 final 的，以确保这一特性。
- 规则 3：要用 ASM 版本 X 的树 API 编写类分析器或适配器，则使用以这一确切版本为参数的构造器创建 ClassNode（而不是使用没有参数的默认构造器）。
- 规则 4：要用 ASM 版本 X 的树 API 编写一个类分析器或适配器，使用别人创建的ClassNode，在以任何方式使用这个 ClassNode 之前，都要以这个确切版本号为参数，调用它的 check()方法。

规则 1 和 2 还适用于 ClassNode、MethodNode 等的子类，asm.tree.analysis 中Interpreter 及其子类的子类，asm.util 中 ASMifier、Texifier 或 CheckXxx Adapter类的子类，asm.commons 包中任意类的子类。最后，规则 2 有两个例外：

- 如果能够完全由自己控制继承链，并同时发布层次结构中的所有类，那就可以使用访问器的继承。然后必须确保层次结构中的所有类都是为同一 ASM 版本编写的。仍然要让 层次结构的叶类是 final 的。
- 如果除了叶类之外，没有其他类重写任何访问方法（例如，如果只是为了引入方便的方法而在  ClassVisitor 和具体访问类之间使用了中间类），那就可以使用“访问器”的继承。仍然要让层次结构的叶类是 final 的（除非它们也没有重写任何访问方法；在这种情况下，提供一个以 ASM 版本为参数的构造器，使子类可以指定它们是为哪个版本编写的）。

